<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="Interpreter for annotated parse trees generated by Language.">
    <title>Interpreter</title>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js" type="text/javascript"></script>
    <script type="text/javascript" src="libs/handlebars-1.0.rc.1.js"></script>
    <script type="text/javascript" src="libs/jQuery-URL-Parser/purl.js"></script>
    <style>
    .category {
        color:blue;
    }
    .details {
        color:green;
    }
    .component {
        color:orange;
    }
    </style>
    <script>
    /*
    This is a universal (AFAIK) interpreter for Language languages.
    By default non-terminals return a list of their evaluated components.
    An "implementation" function can be provided in the production rule.
    Implementation functions take the evaluated components as arguements,
    and their "this" keyword is bound to the processed languageNode (which differs from the one in languageNode.json unfortunately).
    */
    Handlebars.registerHelper('stringify', function(object) {
        return JSON.stringify($.extend({}, object), 2, 4);
    });
    //Temporairy hack until I switch to lazy arrays (see below).
    Array.prototype.at = (function(){
        return function(idx) {
            return this[idx];
        };
    })();
    
    //TODO: Unit test this function.
    //This function might be tricky to make lazy.
    /**
     * Generate array combinations from left to right.
     * TODO: more detail
     **/
    function arrayCombinations(arrays, callback) {
        if(arrays.length > 0) {
            //Empty component arrays would probably cause a problem here.
            //I'm going to make them required. At the very least they should contain the empty string.
            if(arrays.at(0).length > 0){
                arrays.at(0).forEach(function(car){
                    arrayCombinations(arrays.slice(1), function(combination){
                        callback([car].concat(combination));
                    });
                });
            }
        } else {
            callback([])
        }
    }
    
    var tested = 0;
    arrayCombinations([[1]], function(combo) {
        tested++;
        console.assert(combo[0] === 1);
    });
    arrayCombinations([[1,2],[3]], function(combo) {
        tested++;
        console.assert(combo[1] === 3);
    });
    console.assert(tested === 3);
/*
Using a callback in evaluate might not turn out to be the right approach bc it might cause the at() function to be async.

The concrete problem I have now is variable binding.
Right now I'm evaluating bottom up, but I can't evaluate a variable inside a let block this way.
I see two ways out of this:
1. Evaluate top down by treating components as promises and using the at function to force them
2. When unbound variables are encountered delay their evaluation until we go back up the tree.

1 seems like the better option.

Another thing I've been thinking about is how to make it so I can see an "evaluation tree".
The root could be the *set* of possible value or the most common value.
Clicking on a value would show its derivations and the values they rely on.
*/
    /**
     * evaluate a languageNode and call the callback mulitple times with each interpretation.
     **/
    function evaluate(component, callback) {
        /**
         * Evalutae the given array of components (possibly using the function
         * specified by the current component) and pass the result into the callback function.
         **/
        var evalThenCallback = function(components) {
            //Q: Is it better for components to be evaluated prior to being passed into this function?
            //Unevaluated compoents give the componentEvaluator more control over performance,
            //although dealing with multiple interpretations in componentEvaluator functions
            //seems like it would be a headache.
            var componentEvaluator = function(components){ return components; };
            if('content' in component) {
                if('implementation' in component.content) {
                    //console.log(component.content.implementation);
                    //TODO: Make this eval less evil.
                    //The componentEvaluator's `this` keyword is bound to the component,
                    //so the full parseTree is available to it through this.interpretations.
                    componentEvaluator = eval('('+component.content.implementation+')');
                }
            }
            setTimeout(function() {
                try {
                    console.log(components);
                    callback(componentEvaluator.call(component, components));
                } catch (e) {
                    console.error(componentEvaluator);
                    console.error(component);
                    console.error(components);
                    //TODO: Add an error parameter to the evaluate callbacks.
                    throw e;
                }
            }, 0);
        };
        
        if('terminal' in component) {
            evalThenCallback([component.terminal]);
        } else if('match' in component) {
            //TODO: can there be multiple matches?
            evalThenCallback([component.match]);
        } else if('interpretations' in component) {
            component.interpretations.forEach(function(interpretation) {
                var componentsEvaluatedSoFar = interpretation.map(function(){return [];});
                interpretation.forEach(function(component, idx) {
                    evaluate(component, function(possibleValue) {
                        //Generate all the possible combinations of values so far
                        arrayCombinations(componentsEvaluatedSoFar.slice(0,idx), function(leftCombo){
                            arrayCombinations(componentsEvaluatedSoFar.slice(idx + 1), function(rightCombo){
                                var combination = leftCombo.concat([possibleValue]).concat(rightCombo);
                                evalThenCallback(combination);
                            });
                        });
                        //I'm worrying about a callback order problem here.
                        componentsEvaluatedSoFar[idx].push(possibleValue);
                    });
                });
            });
        } else {
            console.error(component);
            throw new Error('?');
        }
    }
    
    $(function() {
        var interpId = $.url().param('interpId');
        $.getJSON($.url().param('serverUrl') + '/interpretations/' + interpId, function(data) {
            console.log(JSON.stringify(data.root));
            //TODO: Where should the evaluation start?
            evaluate(data.root.interpretations[0][0], function(interpretation) {
                var $p = $('<p>');
                $p.text(JSON.stringify(interpretation));
                $('.content').append($p);
            });
        });
    });
    </script>
</head>
<body>
    <div class="content"></div>
</body>
</html>